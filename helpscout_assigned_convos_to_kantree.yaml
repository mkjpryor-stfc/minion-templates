description: >-
  Create or update Kantree cards in a project for each assigned Help Scout conversation in a mailbox.


parameters:
  helpscout.mailbox_name:
    hint: The name of the Help Scout mailbox to fetch conversations from.
    default: CEDA and JASMIN Helpdesk
  kantree.project_name:
    hint: The name of the Kantree project to create cards in.
    example: My Kantree Project
  kantree.groups:
    hint: |
      A list of Kantree groups to apply to created cards.
      Should be formatted as a YAML list containing mappings of the form
      { type: <context name>, name: <group name> }.
    example: "[{type: Projects, name: Support}]"
    default: []
  kantree.active_group:
    hint: |
      A Kantree group to apply to active conversations.
      Should be a YAML map of the form {type: <context name>, name: <group name>}.
    default: {type: Lists, name: Priority}
  kantree.closed_group:
    hint: |
      A Kantree group to apply to closed conversations.
      Should be a YAML map of the form {type: <context name>, name: <group name>}.
    default: {type: Lists, name: Done}


spec:
  functionRef:
    path: minion.functions.compose
    functions:
      # First, move all the current cards representing HS convos to the completed state
      # Then move the cards for active convos to the active state
      # This ensures that convos that are handed over but still active are removed from
      # the active state as far as I am concerned

      - functionRef:
          path: minion.connectors.kantree.cards_for_project
          session:
            connectorRef: "kantree"
          project_name:
            parameterRef: "kantree.project_name"

      # Filter just the support tickets
      - functionRef:
          path: minion.functions.filter
          predicate:
            functionRef:
              path: minion.functions.expression
              expression: "input.model.name == 'Support Ticket'"

      # Produce an iterable of (existing card, updates) tuples to move the cards to the closed status
      - functionRef:
          path: minion.functions.map
          function:
            functionRef:
              path: minion.functions.fork
              functions:
                - functionRef:
                    path: minion.functions.identity
                - functionRef:
                    path: minion.functions.template
                    globals:
                      groups:
                        parameterRef: "kantree.groups"
                      active_group:
                        parameterRef: "kantree.active_group"
                      closed_group:
                        parameterRef: "kantree.closed_group"
                    template: |
                      state: completed
                      groups_add:
                        - type: {{ closed_group.type }}
                          name: {{ closed_group.name }}
                      groups_remove:
                        - type: {{ active_group.type }}
                          name: {{ active_group.name }}

      # Update the cards
      - functionRef:
          path: minion.functions.map
          function:
            functionRef:
              path: minion.connectors.kantree.create_or_update_card
              session:
                connectorRef: "kantree"
              project_name:
                parameterRef: "kantree.project_name"

      # The output of this step is a tuple containing two iterables - (conversations, updated cards)
      - functionRef:
          path: minion.functions.fork
          functions:
            - functionRef:
                path: minion.connectors.helpscout.conversations_assigned_to_user
                session:
                  connectorRef: "helpscout"
                mailbox_name:
                  parameterRef: "helpscout.mailbox_name"
            - functionRef:
                path: minion.functions.identity

      # The output of this step is an iterable of (convo, matching card) tuples
      # If there is no matching card in the project, it is None
      - functionRef:
          path: minion.functions.zip_matching
          matcher:
            functionRef:
              path: minion.functions.expression
              # Getting the attached URLs for a card is pretty contrived
              expression: >-
                input.0._links.web.href in input.1.attributes|selectattr('type', 'eq', 'files')|sum(attribute='value', start=[])|map(attribute='url')

      # The output of this step is an iterable of (existing card, desired state) tuples
      - functionRef:
          path: minion.functions.map
          function:
            functionRef:
              path: minion.functions.fork
              functions:
                - functionRef:
                    path: minion.functions.expression
                    expression: input.1
                - functionRef:
                    path: minion.functions.template
                    globals:
                      groups:
                        parameterRef: "kantree.groups"
                      active_group:
                        parameterRef: "kantree.active_group"
                      closed_group:
                        parameterRef: "kantree.closed_group"
                    template: |
                      title: >-
                        {{ input.0.subject }}
                      model_name: Support Ticket
                      {% if input.0.closedAt and not input.1.finished %}
                      state: completed
                      {% elif not input.0.closedAt and input.1.finished %}
                      state: undecided
                      {% endif %}
                      {% if not input.0.closedAt %}
                      archived: false
                      {% endif %}
                      links:
                        - {{ input.0._links.web.href }}
                      # Use groups for the fixed groups
                      groups:
                      {% for group in groups %}
                        - type: {{ group.type }}
                          name: {{ group.name }}
                      {% else %}
                        []
                      {% endfor %}
                      # Use groups{_add,_remove} for the active/closed groups
                      {% if input.0.closedAt %}
                      groups_add:
                        - type: {{ closed_group.type }}
                          name: {{ closed_group.name }}
                      groups_remove:
                        - type: {{ active_group.type }}
                          name: {{ active_group.name }}
                      {% else %}
                      groups_add:
                        - type: {{ active_group.type }}
                          name: {{ active_group.name }}
                      groups_remove:
                        - type: {{ closed_group.type }}
                          name: {{ closed_group.name }}
                      {% endif %}

      # Create or update the card for each item
      - functionRef:
          path: minion.functions.map
          function:
            functionRef:
              path: minion.connectors.kantree.create_or_update_card
              session:
                connectorRef: "kantree"
              project_name:
                parameterRef: "kantree.project_name"
